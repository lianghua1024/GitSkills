# -*- coding: utf-8 -*-
缩进有利有弊。好处是强迫你写出格式化的代码，但没有规定缩进是几个空格还是Tab。按照约定俗成的管理，应该始终坚持使用4个空格的缩进

字符编码
我们已经讲过了，字符串也是一种数据类型，但是，字符串比较特殊的是还有一个编码问题。
因为计算机只能处理数字，如果要处理文本，就必须先把文本转换为数字才能处理。最早的计算机在设计时采用8个比特（bit）作为一个字节（byte），所以，一个字节能表示的最大的整数就是255（二进制11111111=十进制255），如果要表示更大的整数，就必须用更多的字节。比如两个字节可以表示的最大整数是65535，4个字节可以表示的最大整数是4294967295。
由于计算机是美国人发明的，因此，最早只有127个字母被编码到计算机里，也就是大小写英文字母、数字和一些符号，这个编码表被称为ASCII编码，比如大写字母A的编码是65，小写字母z的编码是122。
但是要处理中文显然一个字节是不够的，至少需要两个字节，而且还不能和ASCII编码冲突，所以，中国制定了GB2312编码，用来把中文编进去。
你可以想得到的是，全世界有上百种语言，日本把日文编到Shift_JIS里，韩国把韩文编到Euc-kr里，各国有各国的标准，就会不可避免地出现冲突，结果就是，在多语言混合的文本中，显示出来会有乱码。
因此，Unicode应运而生。Unicode把所有语言都统一到一套编码里，这样就不会再有乱码问题了。
Unicode标准也在不断发展，但最常用的是用两个字节表示一个字符（如果要用到非常偏僻的字符，就需要4个字节）。现代操作系统和大多数编程语言都直接支持Unicode。
现在，捋一捋ASCII编码和Unicode编码的区别：ASCII编码是1个字节，而Unicode编码通常是2个字节。
字母A用ASCII编码是十进制的65，二进制的01000001；
字符0用ASCII编码是十进制的48，二进制的00110000，注意字符'0'和整数0是不同的；
汉字中已经超出了ASCII编码的范围，用Unicode编码是十进制的20013，二进制的01001110 00101101。
你可以猜测，如果把ASCII编码的A用Unicode编码，只需要在前面补0就可以，因此，A的Unicode编码是00000000 01000001。
新的问题又出现了：如果统一成Unicode编码，乱码问题从此消失了。但是，如果你写的文本基本上全部是英文的话，用Unicode编码比ASCII编码需要多一倍的存储空间，在存储和传输上就十分不划算。
所以，本着节约的精神，又出现了把Unicode编码转化为“可变长编码”的UTF-8编码。UTF-8编码把一个Unicode字符根据不同的数字大小编码成1-6个字节，常用的英文字母被编码成1个字节，汉字通常是3个字节，只有很生僻的字符才会被编码成4-6个字节。如果你要传输的文本包含大量英文字符，用UTF-8编码就能节省空间：

字符	ASCII	    Unicode	            UTF-8
A	    01000001	00000000 01000001	01000001
中	    x	        01001110 00101101	11100100 10111000 10101101

如果你使用Notepad++进行编辑，除了要加上# -*- coding: utf-8 -*-外，中文字符串必须是Unicode字符串：

%运算符就是用来格式化字符串的。在字符串内部，%s表示用字符串替换，%d表示用整数替换，有几个%?占位符，后面就跟几个变量或者值，顺序要对应好。如果只有一个%?，括号可以省略。
常见的占位符有：

%d	整数
%f	浮点数
%s	字符串
%x	十六进制整数

list[] 和 tuple()
append 追加
insert 插入到指定的位置
pop 要删除list末尾的元素，用pop()方法,删除指定位置的元素,用pop(i)方法，其中i是索引位置

二维数组

另一种有序列表叫元组：tuple。tuple和list非常类似，但是tuple一旦初始化就不能修改
Python在显示只有1个元素的tuple时，也会加一个逗号,，以免你误解成数学计算意义上的括号

条件语句：
if语句执行有个特点，它是从上往下判断，如果在某个判断上是True，把该判断对应的语句执行后，就忽略掉剩下的elif和else

raw_input()读取的内容永远以字符串的形式返回

for x in ...循环就是把每个元素代入变量x，然后执行缩进块的语句

字典dict{}

【同步IO】
举个例子来说，比如要把100M的数据写入磁盘，CPU输出100M的数据只需要0.01秒，可是磁盘要接收这100M数据可能需要10秒，怎么办呢？有两种办法
第一种是CPU等着，也就是程序暂停执行后续代码，等100M的数据在10秒后写入磁盘，再接着往下执行，这种模式称为【同步IO】
另一种方法是CPU不等待，只是告诉磁盘，“您老慢慢写，不着急，我接着干别的事去了”，于是，后续代码可以立刻接着执行，这种模式称为【异步IO】

【StringIO/BytesIO】
要把str写入StringIO，我们需要先创建一个StringIO，然后，像文件一样写入即可
getvalue()方法用于获得写入后的str
from io import BytesIO
f = BytesIO()
f.write('中文'.encode('utf-8'))
print(f.getvalue())

【操作目录】
>>> os.path.abspath('.')
'/Users/michael'
# 在某个目录下创建一个新目录，首先把新目录的完整路径表示出来:
>>> os.path.join('/Users/michael', 'testdir')
'/Users/michael/testdir'
# 然后创建一个目录:
>>> os.mkdir('/Users/michael/testdir')
# 删掉一个目录:
>>> os.rmdir('/Users/michael/testdir')

把两个路径合成一个时，不要直接拼字符串，而要通过os.path.join()函数，同样的道理，要拆分路径时，也不要直接去拆字符串，而要通过os.path.split()函数

# 对文件重命名:
>>> os.rename('test.txt', 'test.py')
# 删掉文件:
>>> os.remove('test.py')
os.path.splitext()可以直接让你得到文件扩展名，返回的是一个list
>>> os.path.splitext('/path/to/file.txt')
('/path/to/file', '.txt')

【optionparser的执行过程：】

导入optionparser ： from optparse import OptionParser
构造optionparser的对象：parser = OptionParser()
往optionparser对象中增加option ：parser.add_option()

调用optionparser的解析函数：(options, args) = parser.parse_args()
在options中使用解析到的options，在args中使用其他的args。

def TestOpionparser():
  from optparse import OptionParser
  parser = OptionParser()
  parser.add_option("-f", "--file", dest="filename",
                  help="write report to FILE", metavar="FILE")
  parser.add_option("-q", "--quiet",
                  action="store_false", dest="verbose", default=True,
                  help="don't print status messages to stdout")
  (options, args) = parser.parse_args()
  print (options.filename)
  print (options.verbose)
  print (args)
  
【我们把变量从内存中变成可存储或传输的过程称之为序列化】

import pickle    #导入模块
d = dict(name='Bob', age=20, score=88)    #创建一个字典
f = open('test.txt','wb')    #将要以二进制文件方式写入到f中
pickle.dump(d,f)    #将d写入f
f.close()    #关闭f

g = open('test.txt','rb')    #以二进制格式读入文件
h = pickle.load(g)    #将文件写到h中
g.close()

print(h)

import json
class Student(object):
    def __init__(self,name,age,score):
        self.name = name
        self.age = age
        self.score = score

s = Student('Bob',20,88)

def student2dict(std):
    return {
    'name' : std.name,
    'age' : std.age,
    'score' : std.score
    }

print(json.dumps(s,default = student2dict))

j = {'name':'ted',
'age':20,
'score' : 100
}

print(j['name'])

【进程/线程】
线程是最小的执行单元，而进程由至少一个线程组成。如何调度进程和线程，完全由操作系统决定，程序自己不能决定什么时候执行，执行多长时间。
from multiprocessing import Process
import os

def run_proc(name):
    print('Run child process %s (%s)...')%(name,os.getpid())

if __name__=='__main__':
    print('Parent process %s.'%os.getpid())
    p = Process(target=run_proc,args=('test',))
    print('Child process will start.')
    p.start()
    p.join()
    print('Child process end.')


from multiprocessing import Pool
import os, time, random

def long_time_task(name):
    print('Run task %s (%s)...' % (name, os.getpid()))
    start = time.time()
    time.sleep(random.random() * 3)
    end = time.time()
    print('Task %s runs %0.2f seconds.' % (name, (end - start)))

if __name__=='__main__':
    print('Parent process %s.' % os.getpid())
    p = Pool(4)
    for i in range(5):
        p.apply_async(long_time_task, args=(i,))
    print('Waiting for all subprocesses done...')
    p.close()
    p.join()
    print('All subprocesses done.')

在Unix/Linux下，可以使用fork()调用实现多进程。
要实现跨平台的多进程，可以使用multiprocessing模块。
进程间通信是通过Queue、Pipes等实现的。
from multiprocessing import Process,Queue
import os,time,random

#写数据进程执行的代码：
def write(q):
    print('Process to write:%s'% os.getpid())
    for  value in ['A','B','C']:
        print('Put %s to queue...' % value)
        q.put(value)
        time.sleep(random.random())

#读数据进程执行的代码：
def read(q):
    print('Process to read:%s' % os.getpid())
    while True:
        value = q.get(True)
        print('Get %s from queue.' % value)


if __name__ == '__main__':
    #父进程创建Queue，并传给各个子进程：
    q = Queue()
    pw = Process(target=write,args=(q,))
    pr = Process(target=read,args=(q,))
    #启动子进程pw，写入：
    pw.start()
    #启动子进程pr，读取：
    pr.start()
    #等待pw结束：
    pw.join()
    #强行终止pr进程
    pr.terminate()

【多线程】
Python解释器由于设计时有GIL全局锁，导致了多线程无法利用多核。多线程的并发在Python中就是一个美丽的梦


import time,threading

#新线程执行的代码
def loop():
    print('thread %s is running...' % threading.current_thread().name)
    n = 0
    while n < 5:
        n = n + 1
        print('thread %s >>> %s' % (threading.current_thread().name,n))
        time.sleep(1)
    print('thread %s ended.' % threading.current_thread().name)

print('thread %s is running...' % threading.current_thread().name)
t = threading.Thread(target=loop,name='LoopThread')
t.start()
t.join()
print('thread %s ended.' % threading.current_thread().name)
------------------------------------------------------------------
import time,threading

balance = 0
def change_it(n):
    global balance
    balance = balance + n
    balance = balance - n

def run_thread(n):
    for i in range(100000):
        change_it(n)

t1 = threading.Thread(target=run_thread,args=(5,))
t2 = threading.Thread(target=run_thread,args=(8,))
t1.start()
t2.start()
t1.join()
t2.join()
print(balance)
---------------------------------------------------------
import threading,multiprocessing
balance = 0
lock = threading.Lock()

def run_thread(n):
    for i in range(100000):
        # 先要获取锁:
        lock.acquire()
        try:
            # 放心地改吧:
            change_it(n)
        finally:
            # 改完了一定要释放锁:
            lock.release()

【分布式进程暂时看不懂】
【正则表达式】
用\d可以匹配一个数字，\w可以匹配一个字母或数字
.可以匹配任意字符
用*表示任意个字符（包括0个）
用+表示至少一个字符
用?表示0个或1个字符
用{n}表示n个字符，是前面表达式中字符数量的限制
用{n,m}表示n-m个字符，是前面表达式中字符数量的限制
\s可以匹配一个空格

[0-9a-zA-Z\_]可以匹配一个数字、字母或者下划线；
[0-9a-zA-Z\_]+可以匹配至少由一个数字、字母或者下划线组成的字符串，比如'a100'，'0_Z'，'Py3000'等等；
[a-zA-Z\_][0-9a-zA-Z\_]*可以匹配由字母或下划线开头，后接任意个由一个数字、字母或者下划线组成的字符串，也就是Python合法的变量；
[a-zA-Z\_][0-9a-zA-Z\_]{0, 19}更精确地限制了变量的长度是1-20个字符（前面1个字符+后面最多19个字符）。
A|B可以匹配A或B，所以(P|p)ython可以匹配'Python'或者'python'。
^表示行的开头，^\d表示必须以数字开头。
$表示行的结束，\d$表示必须以数字结束


正则表达式非常强大，要在短短的一节里讲完是不可能的。要讲清楚正则的所有内容，可以写一本厚厚的书了。如果你经常遇到正则表达式的问题，你可能需要一本正则表达式的参考书
m = re.match(r'^(0[0-9]|1[0-9]|2[0-3]|[0-9])\:(0[0-9]|1[0-9]|2[0-9]|3[0-9]|4[0-9]|5[0-9]|[0-9])\:(0[0-9]|1[0-9]|2[0-9]|3[0-9]|4[0-9]|5[0-9]|[0-9])$', t)

【常用模块】
【时间】
from datetime import datetime
nowt = datetime.now()
print(nowt)
dt = nowt.timestamp()
print(dt)
print(datetime.fromtimestamp(dt))
------------------------------------------

【collections】
namedtuple
>>> from collections import namedtuple
>>> Point = namedtuple('Point', ['x', 'y'])
>>> p = Point(1, 2)
>>> p.x
1
>>> p.y
2

deque:deque是为了高效实现插入和删除操作的双向列表，适合用于队列和栈
deque除了实现list的append()和pop()外，还支持appendleft()和popleft()，这样就可以非常高效地往头部添加或删除元素

defaultdict:如果希望key不存在时，返回一个默认值，就可以用defaultdict
from collections import defaultdict

dd = defaultdict(lambda:'N/A')
dd['key1'] = 'abc'
print(dd['key1'])
print(dd['key2'])

OrderedDict:使用dict时，Key是无序的.如果要保持Key的顺序，可以用OrderedDict
注意：OrderedDict的key会按照插入的顺序排列，不是key本身排序。

[ChainMap]

from collections import ChainMap
import os, argparse

# 构造缺省参数:
defaults = {
    'color': 'red',
    'user': 'guest'
}

# 构造命令行参数:
parser = argparse.ArgumentParser()
parser.add_argument('-u', '--user')
parser.add_argument('-c', '--color')
namespace = parser.parse_args()
command_line_args = { k: v for k, v in vars(namespace).items() if v }

# 组合成ChainMap:
combined = ChainMap(command_line_args, os.environ, defaults)

# 打印参数:
print('color=%s' % combined['color'])
print('user=%s' % combined['user'])

【Counter】计数器，返回字符串中每个字符的个数
from collections import Counter
c = Counter()
for ch in 'programming':
    c[ch] = c[ch] + 1
print(c)

[base64]
Base64是一种通过查表的编码方法，不能用于加密
Base64适用于小段内容的编码，比如数字证书签名、Cookie的内容等

[struct]:提供整数转化成二进制数
import struct
n = 10240099
b1 = (n & 0xff000000) >> 24
b2 = (n & 0xff0000) >> 16
b3 = (n & 0xff00) >> 8
b4 = (n & 0xff)
bs = bytes([b1,b2,b3,b4])

print(bs)

print(struct.pack('>I',10240099))

【hashlib】
import hashlib
md5 = hashlib.md5()
md5.update('how are you'.encode('utf-8'))
print(md5.hexdigest())

【hmac】
import hmac,random

def hmac_md5(key,s):
    return hmac.new(key.encode('utf-8'),s.encode('utf-8'),digestmod='MD5').hexdigest()

class User(object):
    def __init__(self,username,password):
        self.username = username
#        self.key = ''.join([chr(random.randint(48,122)) for i in range(20)])
        self.key = '1'
        self.password = hmac_md5(self.key,password)

db = {
    'michael':User('cichael','123456'),
    'bob': User('bob', 'abc999'),
    'alice': User('alice', 'alice2008')
}

def login(username,password):
    user = db[username]
    return user.password == hmac_md5(user.key,password)

print(login('michael', '123456'))

【itertools】操作迭代对象函数
无限序列虽然可以无限迭代下去，但是通常我们会通过takewhile()等函数根据条件判断来截取出一个有限的序列
import itertools

natuals = itertools.count(1)
ns = itertools.takewhile(lambda x : x <= 10,natuals)
for i in ns:
    print(i)

chain()可以把一组迭代对象串联起来，形成一个更大的迭代器
groupby()把迭代器中相邻的重复元素挑出来放在一起

【False的意思】
在python中 None,  False, 空字符串"", 0, 空列表[], 空字典{}, 空元组()都相当于False 

---------------------------------------------
class Query(object):
    def __init__(self,name):
        self.name = name
    def __enter__(self):
        print('Begin')
        return self

    def __exit__(self, exc_type, exc_val, exc_tb):
        print(exc_type)
        if exc_type:
            print('Error')
        else:
            print('End')
    def query(self):
        print('Query info about %s...' %self.name)

if __name__ == '__main__':
    with Query('Bob') as q:
        q.query()

上面的代码简写：
from contextlib import contextmanager

class Query(object):
    def __init__(self,name):
        self.name = name

    def query(self):
        print('Query info about %s...' %self.name)

@contextmanager
def create_query(name):
    print('Begin')
    q = Query(name)
    yield q
    print('End')

if __name__ == '__main__':
    with create_query('Bob') as q:
        q.query()

--------------------------------------------------
from contextlib import contextmanager

@contextmanager
def tag(name):
    print("<%s>" % name)
    yield
    print("</%s>" % name)

with tag("h1"):
    print("hello")
    print("world")
    
【代码的执行顺序是：】

with语句首先执行yield之前的语句，因此打印出<h1>；
yield调用会执行with语句内部的所有语句，因此打印出hello和world；
最后执行yield之后的语句，打印出</h1>。
因此，@contextmanager让我们通过编写generator来简化上下文管理
-------------------------------------------------------
【模拟post发送请求】
from urllib import request, parse

print('Login to weibo.cn...')
email = input('Email: ')
passwd = input('Password: ')
login_data = parse.urlencode([
    ('username', email),
    ('password', passwd),
    ('entry', 'mweibo'),
    ('client_id', ''),
    ('savestate', '1'),
    ('ec', ''),
    ('pagerefer', 'https://passport.weibo.cn/signin/welcome?entry=mweibo&r=http%3A%2F%2Fm.weibo.cn%2F')
])

req = request.Request('https://passport.weibo.cn/sso/login')
req.add_header('Origin', 'https://passport.weibo.cn')
req.add_header('User-Agent', 'Mozilla/6.0 (iPhone; CPU iPhone OS 8_0 like Mac OS X) AppleWebKit/536.26 (KHTML, like Gecko) Version/8.0 Mobile/10A5376e Safari/8536.25')
req.add_header('Referer', 'https://passport.weibo.cn/signin/login?entry=mweibo&res=wel&wm=3349&r=http%3A%2F%2Fm.weibo.cn%2F')

with request.urlopen(req, data=login_data.encode('utf-8')) as f:
    print('Status:', f.status, f.reason)
    for k, v in f.getheaders():
        print('%s: %s' % (k, v))
    print('Data:', f.read().decode('utf-8'))

【XML】
操作XML有两种方法：DOM和SAX。DOM会把整个XML读入内存，解析为树，因此占用内存大，解析慢，优点是可以任意遍历树的节点。SAX是流模式，边读边解析，占用内存小，解析快，缺点是我们需要自己处理事件。
正常情况下，优先考虑SAX，因为DOM实在太占内存
from xml.parsers.expat import ParserCreate

class DefaultSaxHandler(object):
    def start_element(self, name, attrs):
        print('sax:start_element: %s, attrs: %s' % (name, str(attrs)))

    def end_element(self, name):
        print('sax:end_element: %s' % name)

    def char_data(self, text):
        print('sax:char_data: %s' % text)

xml = r'''<?xml version="1.0"?>
<ol>
    <li><a href="/python">Python</a></li>
    <li><a href="/ruby">Ruby</a></li>
</ol>
'''

handler = DefaultSaxHandler()
parser = ParserCreate()
parser.StartElementHandler = handler.start_element
parser.EndElementHandler = handler.end_element
parser.CharacterDataHandler = handler.char_data
parser.Parse(xml)

-------------------------------------------------
【HTMLParser】

[os.environ/sys.path]
对于官方的解释，environ是一个字符串所对应环境的映像对象。这是什么意思呢？举个例子来说，environ['HOME']就代表了当前这个用户的主目录

windows：
os.environ['HOMEPATH']:当前用户主目录。
os.environ['TEMP']:临时目录路径。
os.environ[PATHEXT']:可执行文件。
os.environ['SYSTEMROOT']:系统主目录。
os.environ['LOGONSERVER']:机器名。
os.environ['PROMPT']:设置提示符。

linux：
os.environ['USER']:当前使用用户。
os.environ['LC_COLLATE']:路径扩展的结果排序时的字母顺序。
os.environ['SHELL']:使用shell的类型。
os.environ['LAN']:使用的语言。
os.environ['SSH_AUTH_SOCK']:ssh的执行路径。
路径扩展的结果排序时的字母顺序

sys.path：是python识别模块的路径












