linux 大学网：
https://www.linuxdaxue.com/linux-shell-serial-course.html


linux中shell变量$#,$@,$0,$1,$2的含义解释: 
变量说明: 
$$ 
Shell本身的PID（ProcessID）
 
$! 
Shell最后运行的后台Process的PID 

$? 
最后运行的命令的结束代码（返回值） 

$- 
使用Set命令设定的Flag一览 

$* 
所有参数列表。如"$*"用「"」括起来的情况、以"$1 $2 … $n"的形式输出所有参数。
 
$@ 
所有参数列表。如"$@"用「"」括起来的情况、以"$1" "$2" … "$n" 的形式输出所有参数。
 
$# 
添加到Shell的参数个数 

$0 
Shell本身的文件名 

$1～$n 
添加到Shell的各参数值。$1是第1参数、$2是第2参数…。 

【shell脚本中大于，大于等于，小于，小于等于、不等于的表示方法】
大于 -gt       (greater than) 
小于 -lt      (less than) 
大于或等于 -ge      (greater than or equal) 
小于或等于 -le        (less than or equal) 
不相等 -ne    （not equal）


#!/bin/sh -e
这个-e参数，以前没见过，在网上百度了下，原来-e的参数的作用是：
每条指令之后后，都可以用#？去判断他的返回值，零就是正确执行，非零就是执行有误,
加了-e之后，就不用自己写代码去判断返回值，返回非零，脚本就会退出。

【统计一个字符串在文中出现的次数】
:m,ns/\<字符串\>//gn
cat file | grep -i 字符串 | wc -l

【grep】
  -a或--text   不要忽略二进制的数据。
  -A<显示列数>或--after-context=<显示列数>   除了显示符合范本样式的那一列之外，并显示该列之后的内容。
  -b或--byte-offset   在显示符合范本样式的那一列之前，标示出该列第一个字符的位编号。
  -B<显示列数>或--before-context=<显示列数>   除了显示符合范本样式的那一列之外，并显示该列之前的内容。
  -c或--count   计算符合范本样式的列数。
  -C<显示列数>或--context=<显示列数>或-<显示列数>   除了显示符合范本样式的那一列之外，并显示该列之前后的内容。
  -d<进行动作>或--directories=<进行动作>   当指定要查找的是目录而非文件时，必须使用这项参数，否则grep指令将回报信息并停止动作。
  -e<范本样式>或--regexp=<范本样式>   指定字符串做为查找文件内容的范本样式。
  -E或--extended-regexp   将范本样式为延伸的普通表示法来使用。
  -f<范本文件>或--file=<范本文件>   指定范本文件，其内容含有一个或多个范本样式，让grep查找符合范本条件的文件内容，格式为每列一个范本样式。
  -F或--fixed-regexp   将范本样式视为固定字符串的列表。
  -G或--basic-regexp   将范本样式视为普通的表示法来使用。
  -h或--no-filename   在显示符合范本样式的那一列之前，不标示该列所属的文件名称。
  -H或--with-filename   在显示符合范本样式的那一列之前，表示该列所属的文件名称。
  -i或--ignore-case   忽略字符大小写的差别。
  -l或--file-with-matches   列出文件内容符合指定的范本样式的文件名称。
  -L或--files-without-match   列出文件内容不符合指定的范本样式的文件名称。
  -n或--line-number   在显示符合范本样式的那一列之前，标示出该列的列数编号。
  -q或--quiet或--silent   不显示任何信息。
  -r或--recursive   此参数的效果和指定“-d recurse”参数相同。
  -s或--no-messages   不显示错误信息。
  -v或--revert-match   反转查找。
  -V或--version   显示版本信息。
  -w或--word-regexp   只显示全字符合的列。
  -x或--line-regexp   只显示全列符合的列。
  -y   此参数的效果和指定“-i”参数相同。
  --help   在线帮助。
  
【vim 查找替换】
vi/vim 中可以使用 :s 命令来替换字符串
:s/vivian/sky/ 替换当前行第一个 vivian 为 sky
:s/vivian/sky/g 替换当前行所有 vivian 为 sky
:n,ms/vivian/sky/g 替换当前文件中n-m行的所有vivian 为 sky

:10,15g/^/s//\/\// 在10到15行的行首插入//


从上可知 shift(shift 1) 命令每执行一次，变量的个数($#)减一（之前的$1变量被销毁,之后的$2就变成了$1），而变量值提前一位。

case工作方式如上所示。取值后面必须为关键字 in，每一模式必须以右括号结束。取值可以为变量或常数。
匹配发现取值符合某一模式后，其间所有命令开始执行直至 ;;。
;; 与其他语言中的 break 类似，意思是跳到整个 case 语句的最后,
取值将检测匹配的每一个模式。一旦模式匹配，则执行完匹配模式相应命令后不再继续其他模式。如果无一匹配模式，使用星号 * 捕获该值，再执行后面的命令。


shell 的风格，用倒序的字母单词和 正序的单词配对。
比如 if 语句， 结束时用 fi 来配对
esac是和case配对的，是多路分支的语句

sed是一种流编辑器，它是文本处理中非常中的工具，能够完美的配合正则表达式使用，功能不同凡响。
处理时，把当前处理的行存储在临时缓冲区中，称为“模式空间”（pattern space），接着用sed命令处理缓冲区中的内容，处理完成后，把缓冲区的内容送往屏幕。
a\ 在当前行下面插入文本。
i\ 在当前行上面插入文本。
c\ 把选定的行改为新的文本。
d 删除，删除选择的行。
D 删除模板块的第一行。
s 替换指定字符
h 拷贝模板块的内容到内存中的缓冲区。
H 追加模板块的内容到内存中的缓冲区。
g 获得内存缓冲区的内容，并替代当前模板块中的文本。
G 获得内存缓冲区的内容，并追加到当前模板块文本的后面。
l 列表不能打印字符的清单。
n 读取下一个输入行，用下一个命令处理新的行而不是用第一个命令。
N 追加下一个输入行到模板块后面并在二者间嵌入一个新行，改变当前行号码。
p 打印模板块的行。
P(大写) 打印模板块的第一行。
q 退出Sed。
b lable 分支到脚本中带有标记的地方，如果分支不存在则分支到脚本的末尾。
r file 从file中读行。
t label if分支，从最后一行开始，条件一旦满足或者T，t命令，将导致分支到带有标号的命令处，或者到脚本的末尾。
T label 错误分支，从最后一行开始，一旦发生错误或者T，t命令，将导致分支到带有标号的命令处，或者到脚本的末尾。
w file 写并追加模板块到file末尾。  
W file 写并追加模板块的第一行到file末尾。  
! 表示后面的命令对所有没有被选定的行发生作用。  
= 打印当前行号码。  
# 把注释扩展到下一个换行符以前。  

删除空白行：sed '/^$/d' file
直接编辑文件选项-i
删除文件的第2行：sed '2d' file
删除文件的第2行到末尾所有行：sed '2,$d' file
删除文件最后一行：sed '$d' file

正则表达式 \w\+ 匹配每一个单词，使用 [&] 替换它，& 对应于之前所匹配到的单词：
echo this is a test line | sed 's/\w\+/[&]/g'
[this] [is] [a] [test] [line]

eval命令将会首先扫描命令行进行所有的替换，然后再执行命令
test.txt内容：hello shell world!
myfile="cat test.txt"
(1)echo $myfile　　#result:cat test.txt
(2)eval echo $myfile　　#result:hello shell world!

head 与 tail 就像它的名字一样的浅显易懂，它是用来显示开头或结尾某个数量的文字区块，
head 用来显示档案的开头至标准输出中
tail 想当然尔就是看档案的结尾，看看下面的范例：
## (1)
displays the first 6 lines of a file
head -6 readme.txt
## (2)
displays the last 25 lines of a file
tail -25 mail.txt
范例一是显示档案的前 6 行，范例二则是显示档案最后的 25 行。
而下面的范别，结合 了 head 与 tail 的指令，显示档案的第 11 行到第 20 行
#head与tail一套组合拳：
head -n 10030 application.log | tail -n +10000 #数字前面有个+号就不是从后往前了
输出application.log的10000行至10030行内容


xshell5下 linux终端中常用的快捷键
CTRL + ALT + T: 打开终端
CTRL + D: 关闭标签页==logout
CTRL + L: 清楚屏幕==clear命令
CTRL + A: 移动到行首
CTRL + E: 移动到行末
CTRL + C: 终止当前任务
复制：Ctrl+Insert
粘贴：Shift+Insert


getopt.getopt(args, shortopts, longopts=[])
args指的是当前脚本接收的参数，它是一个列表，可以通过sys.argv获得
shortopts 是短参数　　啥是短参数啊？　　类似于　这样：python test.py -h # 输出帮助信息
longopts  是长参数　　啥是长参数啊？　　类似于　这样：python test.py -help # 输出帮助信息
这个函数返回是一个两元组的列表（复习一下，元组的值是不可修改的！）
举个例子：
---------------------------------------------------------------------------------------
#!/usr/bin/env python3.5
import urllib.request
import getopt
import sys

opts,args = getopt.getopt(sys.argv[1:],'-h-f:-v',['help','filename=','version'])
for opt_name,opt_value in opts:
    if opt_name in ('-h','--help'):
        print("[*] Help info")
        exit()
    if opt_name in ('-v','--version'):
        print("[*] Version is 0.01 ")
        exit()
    if opt_name in ('-f','--filename'):
        fileName = opt_value
        print("[*] Filename is ",fileName)
        # do something
        exit()
--------------------------------------------------------------------------------------
来详细解释一下这几行代码
首先从短参数名开始。
我定义了'-h-f:-v' 大家发现没有，在-f后面多了一个":"
这个":"代表了当前参数是有值的，是一个参数名+参数值的参数
如果我再加一个-o: 那么证明-o后面是可以接收一个值，这个值就是-o的参数值，将会保存到opts变量中。
长参数名的方式和短参数差不多，唯一的区别就是长参数如果要接收值，那必须得在后面加上一个"="







